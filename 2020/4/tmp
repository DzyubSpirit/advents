import Control.Monad (when)
import Data.List.Split (splitOn)
import System.Environment (getArgs)
import Text.ParserCombinators.ReadP (readPrec)
import Text.ParserCombinators.ReadPrec (readPrec, lift)

import qualified Data.Map.Strict as M
import qualified Data.Set as S

main :: IO ()
main = do
  args <- getArgs
  when (length args /= 1) $
    fail $ "Expected one command line argument, got " ++ show args
  passports <- readPassports <$> readFile (head args)
  print $ length $ filter isValid passports

type Passport = M.Map String String

readPassports :: String -> [Passport]
readPassports = map (splitOn ) . splitOn "\n\n"

password :: P.ReadP Passport
password = M.fromList <$> P.sepBy field P.skipSpaces 
  where field = do
          name <- P.munch (/= ':')
          P.char ':'
          val  <- P.munch (not . isSpace)
          return (name, val)

required, optional :: S.Set String
required = S.fromList ["byr", "iyr", "eyr", "hgt", "hcl", "ecl", "pid"]
optional = S.fromList ["cid"]

isValid :: Passport -> Bool
isValid passport =
  S.size (S.intersection fields required) == S.size required && 
  S.size (S.intersection fields optional) == S.size fields - S.size required
    where fields = S.fromList $ M.keys passport

safeHead :: [a] -> Maybe a
safeHead (x:xs) = Just x
safeHead _      = Nothing
